import tkinter as tk
from tkinter import filedialog, ttk
from PIL import Image, ImageTk, ExifTags
import cv2
import os
import sys
import struct
from datetime import datetime

class MediaScanner:
    def __init__(self):
        # 1. Byte Signatures (The "Fingerprints" of AI tools)
        self.signatures = {
            # AI Models
            b"stable diffusion", b"midjourney", b"dall-e", b"adobe firefly",
            b"imagereasoning", b"generated by", b"artificial intelligence",
            b"gemini", b"chatgpt", b"bing image creator", b"comfyui",
            b"stablediffusion", b"synthid", b"xmp:creatorTool", b"sora",
            # AI Video Specifics
            b"runwayml", b"pika labs", b"kling", b"hailuo", b"luma ai",
            b"svd_xt", b"stable video", b"gen-2", b"gen-3",
            # Python/Software Libraries (Used by deepfake scripts)
            b"imageio", b"moviepy", b"scikit-video", b"lavf", b"lavc"
        }

    def extract_metadata(self, fpath, ftype):
        meta = {}
        try:
            stat = os.stat(fpath)
            meta["File Size"] = f"{stat.st_size / (1024*1024):.2f} MB"
            meta["Created"] = datetime.fromtimestamp(stat.st_ctime).strftime('%Y-%m-%d %H:%M:%S')
        except OSError:
            meta["Error"] = "Access Denied"

        if ftype == 'image':
            try:
                with Image.open(fpath) as img:
                    meta["Format"] = img.format
                    meta["Mode"] = img.mode
                    meta["Resolution"] = f"{img.width}x{img.height}"
                    exif = img.getexif()
                    if exif:
                        for tid, val in exif.items():
                            tag = ExifTags.TAGS.get(tid, tid)
                            if isinstance(val, str) and len(val) < 80:
                                meta[f"EXIF: {tag}"] = val
                    if img.info:
                        for k, v in img.info.items():
                            if isinstance(v, (str, bytes)):
                                v_str = str(v)
                                meta[f"Header: {k}"] = (v_str[:50] + '...') if len(v_str) > 50 else v_str
            except: pass

        elif ftype == 'video':
            try:
                cap = cv2.VideoCapture(fpath)
                meta["FPS"] = f"{cap.get(cv2.CAP_PROP_FPS):.2f}"
                meta["Total Frames"] = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                dur = meta["Total Frames"] / (float(meta["FPS"]) or 1)
                meta["Duration"] = f"{dur:.2f}s"
                meta["Resolution"] = f"{int(cap.get(3))}x{int(cap.get(4))}"
                
                # Codec Tag Extraction
                codec_int = int(cap.get(cv2.CAP_PROP_FOURCC))
                try:
                    res = "".join([chr((codec_int >> 8 * i) & 0xFF) for i in range(4)])
                    meta["Codec"] = res.lower()
                except:
                    meta["Codec"] = str(codec_int)
                cap.release()
            except: pass

        return meta

    def analyze_authenticity(self, fpath, ftype):
        flags = []
        score = 0
        
        # --- 1. CONTAINER ANALYSIS ---
        try:
            with open(fpath, "rb") as f:
                header = f.read(1024).lower()
                
                if ftype == 'video':
                    if b"ftypisom" in header:
                        score += 35
                        flags.append("Generic Container (isom): Likely created by software/script.")
                    elif b"ftypqt" in header or b"ftypmp4" in header:
                        score -= 10 
        except: pass

        # --- 2. DEEP SIGNATURE SCAN ---
        try:
            with open(fpath, "rb") as f:
                head = f.read(5 * 1024 * 1024).lower()
                try: f.seek(-5 * 1024 * 1024, 2)
                except: f.seek(0)
                tail = f.read().lower()
                blob = head + tail
                
                for sig in self.signatures:
                    if sig in blob:
                        if sig in [b"lavf", b"lavc"]:
                            score += 40
                            flags.append(f"Software Encoder ({sig.decode()}): Common in AI generation.")
                        elif sig in [b"imageio", b"moviepy", b"scikit-video"]:
                            score += 80
                            flags.append(f"Python Library ({sig.decode()}): Strong indicator of script.")
                        else:
                            score += 100
                            flags.append(f"AI Signature Match: '{sig.decode()}'")
        except: pass

        # --- 3. HEURISTICS ---
        if ftype == 'video':
            try:
                cap = cv2.VideoCapture(fpath)
                fps = cap.get(cv2.CAP_PROP_FPS)
                frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))
                duration = frame_count / (fps or 1)
                
                if duration < 15 and fps.is_integer():
                    score += 15
                    flags.append(f"Suspicious Profile: Short ({duration:.1f}s) with flat FPS ({fps})")
                
                ret, frame = cap.read()
                if ret:
                    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
                    lap_var = cv2.Laplacian(gray, cv2.CV_64F).var()
                    if lap_var < 50:
                        score += 20
                        flags.append("Frame Texture: Unnaturally smooth (Low Noise)")
                cap.release()
            except: pass

        # --- VERDICT ---
        if score >= 60:
            return "Likely Generated", "#d32f2f", flags
        elif score >= 30:
            return "Suspicious / Software Encode", "#f57c00", flags
        else:
            return "Likely Authentic", "#388e3c", []


class IsItRealApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Google Dev Tool: IsItReal")
        self.root.geometry("900x700")
        self.root.configure(bg="#eceff1")
        self.scanner = MediaScanner()
        self._init_ui()

    def _init_ui(self):
        # Header
        top = tk.Frame(self.root, bg="#1976d2", height=75)
        top.pack(fill=tk.X)
        tk.Label(top, text="IsItReal Analyzer", font=("Roboto", 20, "bold"), 
                 bg="#1976d2", fg="white").pack(pady=20)

        # Layout
        main = tk.Frame(self.root, bg="#eceff1")
        main.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)

        # Left (Control)
        left = tk.Frame(main, bg="white", width=380)
        left.pack(side=tk.LEFT, fill=tk.Y, padx=(0, 15))
        left.pack_propagate(False)

        tk.Button(left, text="üìÇ Upload Media", command=self._handle_upload,
                 bg="#1976d2", fg="white", font=("Roboto", 12), relief=tk.FLAT,
                 pady=10, cursor="hand2").pack(fill=tk.X, padx=20, pady=20)

        self.preview_lbl = tk.Label(left, text="Supports: JPG, PNG, MP4, WEBM, MKV, GIF...", 
                                  bg="#f5f5f5", fg="#90a4ae", wraplength=300)
        self.preview_lbl.pack(fill=tk.BOTH, expand=True, padx=20, pady=(0, 20))

        # Right (Results)
        right = tk.Frame(main, bg="#eceff1")
        right.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)

        # Verdict Box
        self.v_frame = tk.LabelFrame(right, text="Verdict", bg="white", font=("Roboto", 11, "bold"))
        self.v_frame.pack(fill=tk.X, pady=(0, 15), ipady=10)
        
        # FIX IS HERE: Added wraplength=450 so long text wraps to next line
        self.lbl_verdict = tk.Label(self.v_frame, text="Ready to Scan", font=("Roboto", 18, "bold"), 
                                  bg="white", fg="#cfd8dc", wraplength=450)
        self.lbl_verdict.pack(pady=5)
        
        self.lbl_flags = tk.Label(self.v_frame, text="", bg="white", fg="#546e7a", wraplength=450)
        self.lbl_flags.pack(pady=(0, 10))

        # Metadata Box
        m_frame = tk.LabelFrame(right, text="Container Metadata", bg="white", font=("Roboto", 11, "bold"))
        m_frame.pack(fill=tk.BOTH, expand=True)

        self.txt_meta = tk.Text(m_frame, bg="#fafafa", relief=tk.FLAT, font=("Consolas", 10),
                              state=tk.DISABLED, padx=10, pady=10)
        self.txt_meta.pack(fill=tk.BOTH, expand=True)

    def _handle_upload(self):
        fpath = filedialog.askopenfilename(filetypes=[
            ("All Supported", "*.jpg *.jpeg *.png *.webp *.mp4 *.mov *.avi *.mkv *.webm *.flv *.gif"),
            ("Images", "*.jpg *.jpeg *.png *.webp *.gif"),
            ("Videos", "*.mp4 *.mov *.avi *.mkv *.webm *.flv")
        ])
        if not fpath: return

        vid_exts = ['.mp4', '.mov', '.avi', '.mkv', '.webm', '.flv']
        ftype = 'video' if any(fpath.lower().endswith(e) for e in vid_exts) else 'image'
        
        self._run_scan(fpath, ftype)

    def _run_scan(self, fpath, ftype):
        self.preview_lbl.config(image='', text=f"Analyzing:\n{os.path.basename(fpath)}")
        self.root.update()

        # 1. Preview
        if ftype == 'image':
            try:
                img = Image.open(fpath)
                img.thumbnail((340, 340))
                photo = ImageTk.PhotoImage(img)
                self.preview_lbl.config(image=photo, text="")
                self.preview_lbl.image = photo
            except: pass
        else:
            self.preview_lbl.config(text=f"üé• VIDEO DETECTED\n{os.path.basename(fpath)}")

        # 2. Analyze
        meta = self.scanner.extract_metadata(fpath, ftype)
        verdict, color, flags = self.scanner.analyze_authenticity(fpath, ftype)

        # 3. Render
        self.lbl_verdict.config(text=verdict, fg=color)
        flag_text = "‚ö†Ô∏è Detection Flags:\n" + "\n".join([f"‚Ä¢ {f}" for f in flags]) if flags else "‚úÖ No anomalies found in container or byte stream."
        self.lbl_flags.config(text=flag_text)
        
        self.txt_meta.config(state=tk.NORMAL)
        self.txt_meta.delete(1.0, tk.END)
        for k, v in meta.items():
            self.txt_meta.insert(tk.END, f"{k:<15} : {v}\n")
        self.txt_meta.config(state=tk.DISABLED)

if __name__ == "__main__":
    root = tk.Tk()
    try:
        style = ttk.Style()
        style.theme_use('clam')
    except: pass
    app = IsItRealApp(root)
    root.mainloop()